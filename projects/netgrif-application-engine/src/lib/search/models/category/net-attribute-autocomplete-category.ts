import {NoConfigurationAutocompleteCategory} from './no-configuration-autocomplete-category';
import {NetAttributePair} from './net-attribute-pair';
import {CaseProcess} from './case/case-process';
import {Operator} from '../operator/operator';
import {LoggerService} from '../../../logger/services/logger.service';
import {Net} from '../../../process/net';
import {NameIdPair} from './name-id-pair';
import {Query} from '../query/query';
import {BooleanOperator} from '../boolean-operator';
import {Category} from './category';
import {Observable} from 'rxjs';

/**
 * A utility class for autocomplete search categories that are net specific, such as searching by roles, or tasks.
 *
 * The generated queries combine the ids of the selected attribute with the net id, so that no unexpected results are found.
 */
export abstract class NetAttributeAutocompleteCategory extends NoConfigurationAutocompleteCategory<NetAttributePair> {

    protected constructor(elasticKeywords: Array<string>,
                          allowedOperators: Array<Operator<any>>,
                          translationPath: string,
                          log: LoggerService) {
        super(elasticKeywords, allowedOperators, translationPath, log);
    }

    protected createOptions(): void {
        this.getAllowedNets$().subscribe(allowedNets => {
            allowedNets.forEach(petriNet => {
                this.extractAttributes(petriNet).forEach(pair => {
                    this.addToMap(pair.name, {
                        netId: petriNet.stringId,
                        attributeId: pair.id
                    });
                });
            });
        });
    }

    /**
     * This method should provide the allowed nets that are processed to create the options of this category.
     *
     * Since this class aims to be a universal implementation and allowed nets are provided in either the
     * {@Link CaseViewService}, or the {@link TaskViewService}, we must demand the source from a subclass.
     */
    protected abstract getAllowedNets$(): Observable<Array<Net>>;

    /**
     * This method should extract the relevant attribute display names and ids.
     * They will be automatically paired with the net id for further use by this search category.
     *
     * @param petriNet Petri net that should have its search relevant attributes extracted
     * @returns an array of the attribute display name and id pairs
     */
    protected abstract extractAttributes(petriNet: Net): Array<NameIdPair>;

    /**
     *  This method should return the appropriate category instance for searching of processes, so that process queries
     *  can be generated with it.
     *
     *  Currently it can be either the {@link CaseProcess} or the {@link TaskProcess} category class.
     */
    protected abstract getProcessCategory(): Category<Array<string>>;

    /**
     * Generates the query as a combination of the selected attribute pairs.
     * Each attribute is ANDed with its net id and ORed with other attributes.
     * @param userInput inputs selected by the user in each of the operand input fields
     * @returns the Query generated by the selected Operator
     */
    protected generateQuery(userInput: Array<Array<NetAttributePair>>): Query {
        if (userInput.length !== 1) {
            throw new Error('NetAttributeAutocompleteCategories currently doesn\'t support operators with arity other than 1!');
        }

        const matchingPairs = userInput[0];

        const queries = matchingPairs.map(pair => {
            const taskQuery = this.selectedOperator.createQuery(this.elasticKeywords, [pair.attributeId]);
            const netQuery = this.getProcessCategory().generatePredicate([[pair.netId]]).query;
            return Query.combineQueries([taskQuery, netQuery], BooleanOperator.AND);
        });
        return Query.combineQueries(queries, BooleanOperator.OR);
    }
}
