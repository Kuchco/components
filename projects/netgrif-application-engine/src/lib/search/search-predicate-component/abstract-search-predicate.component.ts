import {Inject, Input, OnDestroy, ViewChild} from '@angular/core';
import {EditableElementaryPredicate} from '../models/predicate/editable-elementary-predicate';
import {Subject, Subscription} from 'rxjs';
import {NAE_SEARCH_CATEGORIES} from '../category-factory/search-categories-injection-token';
import {Category} from '../models/category/category';
import {SearchAutocompleteOption} from '../models/category/search-autocomplete-option';
import {ElementaryPredicate} from '../models/predicate/elementary-predicate';
import {Query} from '../models/query/query';
import {LoggerService} from '../../logger/services/logger.service';
import {MatSelect} from '@angular/material/select';


/**
 * Is responsible for the interactive creation of a single {@link ElementaryPredicate} object instance.
 */
export abstract class AbstractSearchPredicateComponent implements OnDestroy {

    @Input() predicate: EditableElementaryPredicate;
    @Input() predicateId: number;
    @Input() remove$: Subject<number>;

    public selectedCategory: Category<any>;

    protected _predicateChange: Subscription;

    protected _searchCategories: Array<Category<any>>;

    protected constructor(@Inject(NAE_SEARCH_CATEGORIES) searchCategories: Array<Category<any>>,
                          protected _logger: LoggerService) {
        this._searchCategories = searchCategories.map(category => category.duplicate());
    }

    ngOnDestroy(): void {
        if (this._predicateChange && !this._predicateChange.closed) {
            this._predicateChange.unsubscribe();
        }
    }

    public get searchCategories(): Array<Category<any>> {
        return this._searchCategories;
    }

    @ViewChild('categoryInput')
    public set categoryInput(input: MatSelect) {
        if (input) {
            setTimeout(() => {
                input.focus();
                input.open();
            });
        }
    }

    /**
     * Lambda that is used to preserve `this` reference in HTML binding.
     *
     * See [_renderSelection()]{@link AbstractSearchPredicateComponent#_renderSelection} for information about the transform function.
     * @param option the {@link SearchAutocompleteOption} object that was selected in the autocomplete list.
     */
    public renderSelection = (option: SearchAutocompleteOption<unknown>) => this._renderSelection(option);

    public remove(): void {
        this.remove$.next(this.predicateId);
    }

    public categoryChanged(newCategory: Category<any>): void {
        if (this.selectedCategory !== undefined) {
            this.selectedCategory.reset();
        }
        this.selectedCategory = newCategory;
        if (newCategory !== undefined) {
            if (this._predicateChange) {
                this._predicateChange.unsubscribe();
            }
            this._predicateChange = newCategory.generatedPredicate$.subscribe(predicate => this.processPredicateChange(predicate));
        }
    }

    public clearCategorySelection(): void {
        this.categoryChanged(undefined);
    }

    /**
     * Transforms a {@link SearchAutocompleteOption} object into it's name.
     * Used for displaying user selection in the input field, when an autocomplete option is selected.
     * @param option the object we want to transform. It might not exist if user input doesn't match any autocomplete option
     * @returns option name if it exists, empty string otherwise
     */
    protected _renderSelection(option: SearchAutocompleteOption<unknown>): string {
        return option ? option.text : '';
    }

    /**
     * Notifies the `EditableElementaryPredicate` about changes to the predicate generated by the selected `Category`.
     * @param newPredicate predicate generated by the selected `Category`
     */
    protected processPredicateChange(newPredicate: ElementaryPredicate | undefined): void {
        if (newPredicate === undefined) {
            this.predicate.query = Query.emptyQuery();
            this._logger.debug('Editable query changed to empty query');
        } else {
            this.predicate.query = newPredicate.query;
            this._logger.debug(`Editable query changed to: ${newPredicate.query.value}`);
        }
    }
}
